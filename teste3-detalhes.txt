001000|00000|10000|0000000001000000 //addi $16, $0, 64 // $16 = 0 + 64
000000|10000|00001|00011|00000|100000//add $3, $16, $1 // $3 = $16 + $1 = 64 + 1001 = 1065
000000|00011|00001|00100|00000|100010//sub $4, $3, $1 // $4 = 1065-1001 = 64
000000|00100|01110|01111|00000|100100//and $15, $4, $14 //$15 = 64 & -1014 = 0
000000|00100|01110|10000|00000|100101//or  $16, $4, $14 //$16 = 64 | -1014 = -950 ( unsigned 4294966346)
101011|11101|00100|0000000000011100//sw $4, $29(28) // mem[3+28] = $4 = 64
100011|11101|00010|0000000000011100//lw $2, $29(28) // $2 = mem[3+28] = 64
000000|00000|00010|00110|00010|000000//sll $6, $2, 2 // $6 = 64*4 = 256
000000|00010|00110|01010|00000101010//slt $10, $2, $6 // $10 = $2 < $6 = 1
000100|00000|01111|1111111111010111//beq $15, $0, -41 // if(0 == 0) { pc = pc + 4 - 41*4 } (volta para a instrução add, segunda instrução da lista)


000000|00001|00010|00011|00000|100000//add $3, $1, $2
101011|11101|00100|0000000000011100//sw $4, $29(28) // mem[3+28] = $4 = 64
100011|11101|00010|0000000000011100//lw $2, $29(28) // $2 = mem[3+28] = 64
000100|00000|00010|0000000000000101//beq $2, $0, 5
000101|00001|00010|0000000000001001//bne $1, $2, 9
000000|01010|01000|01001|00000101010//slt $9, $10, $8
000000|00000|01000|01001|00010|000000//sll $9, $8, 2
000000|01010|01011|01100|00000|100010//sub opcode:0 rs:10 rt:11 rd:12 shamt:0 funct:22(hex)
000000|01101|01110|01111|00000|100100//and opcode:0 rs:13 rt:14 rd:15 shamt:0 funct:24(hex)
000000|01000|01001|01010|00000|100101//or opcode:0 rs:8 rt:9 rd:10 shamt:0 funct:25(hex)
001000|01001|01000|0000000000000100 //addi $8, $9, 4
001000|01001|01000|1111111111111100 //addi $8, $9, -4
00001000000000000000000000001001//j 9
000000|00010|00000|00000|00000|001000//jr $2
000011|00000000000000000000001010// jal 10